// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax
{
    using System;
    using System.Collections.Generic;
    using SkiaMarkdown.Syntax.Green;
    using SkiaMarkdown.Syntax.Parsing;
    using SkiaMarkdown.Syntax.Red;
    using SkiaMarkdown.Syntax.Semantics;

    /// <summary>
    /// Provides entry points for parsing Markdown into Roslyn-style syntax trees.
    /// </summary>
    public sealed class MarkdownSyntaxTree
    {
        private readonly string text;
        private readonly MarkdownSyntaxOptions options;
        private readonly GreenNode greenRoot;
        private MarkdownSyntaxNode? root;

        private MarkdownSyntaxTree(string text, MarkdownSyntaxOptions options, GreenNode greenRoot)
        {
            this.text = text;
            this.options = options;
            this.greenRoot = greenRoot;
        }

        public static MarkdownSyntaxTree Parse(string text, MarkdownSyntaxOptions? options = null)
        {
            if (text is null)
            {
                throw new ArgumentNullException(nameof(text));
            }

            var appliedOptions = options ?? MarkdownSyntaxOptions.Default;
            var green = MarkdownSyntaxParser.ParseDocument(text.AsMemory(), appliedOptions);
            return new MarkdownSyntaxTree(text, appliedOptions, green);
        }

        public MarkdownSyntaxNode GetRoot() =>
            root ??= MarkdownSyntaxNode.Create(parent: null, green: greenRoot, position: 0);

        public string GetText() => text;

        public IReadOnlyList<MarkdownInlineSemantic> GetInlineSemantics(MarkdownSyntaxNode node, out IReadOnlyList<MarkdownDiagnostic> diagnostics) =>
            InlineSemanticModelBuilder.Build(node, options, out diagnostics);

        public MarkdownTableSemantic GetTableSemantic(MarkdownSyntaxNode tableNode, out IReadOnlyList<MarkdownDiagnostic> diagnostics) =>
            TableSemanticModel.Build(tableNode, options, out diagnostics);

        public IReadOnlyList<MarkdownTableSemantic> GetTableSemantics(out IReadOnlyList<MarkdownDiagnostic> diagnostics)
        {
            var results = new List<MarkdownTableSemantic>();
            var diagnosticList = new List<MarkdownDiagnostic>();

            foreach (var table in EnumerateNodes(GetRoot(), MarkdownSyntaxKind.TableBlock))
            {
                var tableSemantic = TableSemanticModel.Build(table, options, out var tableDiagnostics);
                results.Add(tableSemantic);
                diagnosticList.AddRange(tableDiagnostics);
            }

            diagnostics = diagnosticList;
            return results;
        }

        internal GreenNode GetGreenRoot() => greenRoot;

        private static IEnumerable<MarkdownSyntaxNode> EnumerateNodes(MarkdownSyntaxNode node, MarkdownSyntaxKind kind)
        {
            foreach (var child in node.ChildNodes())
            {
                if (child.Kind == kind)
                {
                    yield return child;
                }

                foreach (var nested in EnumerateNodes(child, kind))
                {
                    yield return nested;
                }
            }
        }
    }
}
