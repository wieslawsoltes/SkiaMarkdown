// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Parsing
{
    using System;
    using System.Collections.Generic;
    using SkiaMarkdown.Syntax;

    /// <summary>
    /// Lightweight tokenizer that emits block-level Markdown tokens for the Roslyn syntax pipeline.
    /// </summary>
    internal ref struct MarkdownTokenizer
    {
        private const int FenceMarkerShift = 16;

        private readonly ReadOnlySpan<char> source;
        private readonly bool enableGitHubExtensions;
        private readonly int baseOffset;
        private readonly int baseLine;

        private int position;
        private int line;

        private List<MarkdownToken>? pendingTokens;
        private int pendingIndex;

        public MarkdownTokenizer(ReadOnlySpan<char> source, bool enableGitHubExtensions, int baseOffset = 0, int baseLine = 0)
        {
            this.source = source;
            this.enableGitHubExtensions = enableGitHubExtensions;
            this.baseOffset = baseOffset;
            this.baseLine = baseLine;
            position = 0;
            line = 0;
            pendingTokens = null;
            pendingIndex = 0;
        }

        public bool TryRead(out MarkdownToken token)
        {
            if (pendingTokens is not null)
            {
                if (pendingIndex < pendingTokens.Count)
                {
                    token = pendingTokens[pendingIndex++];
                    if (pendingIndex >= pendingTokens.Count)
                    {
                        pendingTokens = null;
                        pendingIndex = 0;
                    }

                    return true;
                }

                pendingTokens = null;
                pendingIndex = 0;
            }

            if (position >= source.Length)
            {
                token = MarkdownToken.End(new TextSpan(baseOffset + source.Length, 0), baseLine + line, 0);
                return false;
            }

            var info = ReadLineInfo(position);

            if (info.IsBlank)
            {
                var startLine = line;
                Advance(info.TotalLength);
                token = new MarkdownToken(
                    MarkdownTokenKind.BlankLine,
                    new TextSpan(baseOffset + info.Start, info.TotalLength),
                    baseLine + startLine,
                    info.Column,
                    0);
                return true;
            }

        if (TryReadFencedCodeBlock(info, out token))
        {
            return true;
        }

        if (enableGitHubExtensions && TryReadFootnoteDefinition(info, out token))
        {
            return true;
        }

        if (TryReadCustomContainer(info, out token))
        {
            return true;
        }

            if (TryReadHtmlBlock(info, out token))
            {
                return true;
            }

            if (enableGitHubExtensions && TryReadTable(info, out token))
            {
                return true;
            }

            if (TryReadHeading(info, out token) ||
                TryReadThematicBreak(info, out token) ||
                TryReadBlockQuote(info, out token) ||
                TryReadListItem(info, out token))
            {
                return true;
            }

            var defaultStartLine = line;
            Advance(info.TotalLength);
        token = new MarkdownToken(
            MarkdownTokenKind.Text,
            new TextSpan(baseOffset + info.Start, info.TotalLength),
            baseLine + defaultStartLine,
            info.Column,
            0);
        return true;
    }

    private bool TryReadHeading(LineInfo info, out MarkdownToken token)
    {
        var trimmed = info.Trimmed;
        var level = 0;
        while (level < trimmed.Length && trimmed[level] == '#')
        {
            level++;
        }

        if (level == 0 || level > 6)
        {
            token = default;
            return false;
        }

        if (level < trimmed.Length && trimmed[level] == ' ')
        {
            var startLine = line;
            Advance(info.TotalLength);
            token = new MarkdownToken(
                MarkdownTokenKind.Heading,
                new TextSpan(baseOffset + info.Start, info.TotalLength),
                baseLine + startLine,
                info.Column,
                level);
            return true;
        }

        token = default;
        return false;
    }

    private bool TryReadFootnoteDefinition(LineInfo info, out MarkdownToken token)
    {
        var trimmed = info.Trimmed;
        if (!trimmed.StartsWith("[^", StringComparison.Ordinal))
        {
            token = default;
            return false;
        }

        var closingBracket = trimmed.IndexOf(']');
        if (closingBracket < 2 || closingBracket + 1 >= trimmed.Length || trimmed[closingBracket + 1] != ':')
        {
            token = default;
            return false;
        }

        var definitionStart = info.Start;
        var definitionEnd = info.Start + info.TotalLength;
        var localPosition = info.Start + info.TotalLength;

        while (localPosition < source.Length)
        {
            var lookahead = ReadLineInfo(localPosition);
            if (!lookahead.IsBlank && lookahead.Column > info.Column)
            {
                definitionEnd = lookahead.Start + lookahead.TotalLength;
                localPosition = lookahead.Start + lookahead.TotalLength;
                continue;
            }

            break;
        }

        var spanStart = baseOffset + definitionStart;
        var spanEnd = baseOffset + definitionEnd;
        AdvanceTo(definitionEnd);
        token = new MarkdownToken(
            MarkdownTokenKind.FootnoteDefinition,
            TextSpan.FromBounds(spanStart, spanEnd),
            baseLine + line,
            info.Column,
            0);
        return true;
    }

        private bool TryReadThematicBreak(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            var marker = '\0';
            var count = 0;

            for (var i = 0; i < trimmed.Length; i++)
            {
                var ch = trimmed[i];
                if (ch is '-' or '*' or '_')
                {
                    if (marker == '\0')
                    {
                        marker = ch;
                    }

                    if (ch == marker)
                    {
                        count++;
                    }
                }
                else if (!char.IsWhiteSpace(ch))
                {
                    token = default;
                    return false;
                }
            }

            if (count >= 3)
            {
                var startLine = line;
                Advance(info.TotalLength);
                token = new MarkdownToken(
                    MarkdownTokenKind.ThematicBreak,
                    new TextSpan(baseOffset + info.Start, info.TotalLength),
                    baseLine + startLine,
                    info.Column,
                    count);
                return true;
            }

            token = default;
            return false;
        }

        private bool TryReadBlockQuote(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            if (trimmed.IsEmpty || trimmed[0] != '>')
            {
                token = default;
                return false;
            }

            var depth = 0;
            var index = 0;
            while (index < trimmed.Length && trimmed[index] == '>')
            {
                depth++;
                index++;
                if (index < trimmed.Length && trimmed[index] == ' ')
                {
                    index++;
                }
            }

            var startLine = line;
            Advance(info.TotalLength);
            token = new MarkdownToken(
                MarkdownTokenKind.BlockQuote,
                new TextSpan(baseOffset + info.Start, info.TotalLength),
                baseLine + startLine,
                info.Column,
                depth);
            return true;
        }

        private bool TryReadListItem(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            if (trimmed.IsEmpty)
            {
                token = default;
                return false;
            }

            if (trimmed[0] is '-' or '+' or '*')
            {
                if (trimmed.Length > 1 && trimmed[1] == ' ')
                {
                    var startLine = line;
                    Advance(info.TotalLength);
                    token = new MarkdownToken(
                        MarkdownTokenKind.UnorderedListItem,
                        new TextSpan(baseOffset + info.Start, info.TotalLength),
                        baseLine + startLine,
                        info.Column,
                        0);
                    return true;
                }
            }

            var index = 0;
            while (index < trimmed.Length && char.IsDigit(trimmed[index]))
            {
                index++;
            }

            if (index > 0 && index < trimmed.Length && (trimmed[index] is '.' or ')'))
            {
                if (index + 1 < trimmed.Length && trimmed[index + 1] == ' ')
                {
                    var number = int.Parse(trimmed[..index], System.Globalization.CultureInfo.InvariantCulture);
                    var startLine = line;
                    Advance(info.TotalLength);
                    token = new MarkdownToken(
                        MarkdownTokenKind.OrderedListItem,
                        new TextSpan(baseOffset + info.Start, info.TotalLength),
                        baseLine + startLine,
                        info.Column,
                        EncodeOrderedListValue(number, MarkdownTaskState.None));
                    return true;
                }
            }

            token = default;
            return false;
        }

        private bool TryReadFencedCodeBlock(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            if (!IsFenceDelimiter(trimmed, out var marker, out var markerLength))
            {
                token = default;
                return false;
            }

            var startLine = line;

            var currentPosition = info.Start + info.TotalLength;

            while (currentPosition < source.Length)
            {
                var innerInfo = ReadLineInfo(currentPosition);
                var innerTrimmed = innerInfo.Trimmed;
                if (IsFenceDelimiter(innerTrimmed, out var otherMarker, out var otherLength) &&
                    otherMarker == marker &&
                    otherLength >= markerLength)
                {
                    var spanStart = baseOffset + info.Start;
                    var spanEnd = baseOffset + innerInfo.Start + innerInfo.TotalLength;
                    AdvanceTo(innerInfo.Start + innerInfo.TotalLength);
                    token = new MarkdownToken(
                        MarkdownTokenKind.FencedCodeBlock,
                        TextSpan.FromBounds(spanStart, spanEnd),
                        baseLine + startLine,
                        info.Column,
                        EncodeFence(marker, markerLength));
                    return true;
                }

                currentPosition = innerInfo.Start + innerInfo.TotalLength;
            }

            var finalSpanStart = baseOffset + info.Start;
            AdvanceTo(source.Length);
            token = new MarkdownToken(
                MarkdownTokenKind.FencedCodeBlock,
                TextSpan.FromBounds(finalSpanStart, baseOffset + source.Length),
                baseLine + startLine,
                info.Column,
                EncodeFence(marker, markerLength));
            return true;
        }

        private bool TryReadCustomContainer(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            if (!trimmed.StartsWith(":::", StringComparison.Ordinal))
            {
                token = default;
                return false;
            }

            var startLine = line;
            var currentPosition = info.Start + info.TotalLength;
            while (currentPosition < source.Length)
            {
                var inner = ReadLineInfo(currentPosition);
                var innerTrimmed = inner.Trimmed;
                if (innerTrimmed.StartsWith(":::", StringComparison.Ordinal))
                {
                    var spanStart = baseOffset + info.Start;
                    var spanEnd = baseOffset + inner.Start + inner.TotalLength;
                    AdvanceTo(inner.Start + inner.TotalLength);
                    token = new MarkdownToken(
                        MarkdownTokenKind.CustomContainer,
                        TextSpan.FromBounds(spanStart, spanEnd),
                        baseLine + startLine,
                        info.Column,
                        0);
                    return true;
                }

                currentPosition = inner.Start + inner.TotalLength;
            }

            var finalStart = baseOffset + info.Start;
            AdvanceTo(source.Length);
            token = new MarkdownToken(
                MarkdownTokenKind.CustomContainer,
                TextSpan.FromBounds(finalStart, baseOffset + source.Length),
                baseLine + startLine,
                info.Column,
                0);
            return true;
        }

        private bool TryReadHtmlBlock(LineInfo info, out MarkdownToken token)
        {
            var trimmed = info.Trimmed;
            if (trimmed.IsEmpty || trimmed[0] != '<')
            {
                token = default;
                return false;
            }

            var startLine = line;
            var start = info.Start;
            var currentPosition = info.Start + info.TotalLength;
            var currentLine = line;

            while (currentPosition < source.Length)
            {
                var inner = ReadLineInfo(currentPosition);
                if (inner.IsBlank)
                {
                    break;
                }

                currentPosition = inner.Start + inner.TotalLength;
                currentLine++;
            }

            var spanStart = baseOffset + start;
            AdvanceTo(currentPosition);
            token = new MarkdownToken(
                MarkdownTokenKind.HtmlBlock,
                TextSpan.FromBounds(spanStart, baseOffset + currentPosition),
                baseLine + startLine,
                info.Column,
                0);
            return true;
        }

        private bool TryReadTable(LineInfo info, out MarkdownToken token)
        {
            if (!enableGitHubExtensions)
            {
                token = default;
                return false;
            }

            var header = info;
            if (!header.Content.Contains('|'))
            {
                token = default;
                return false;
            }

            var delimiterOffset = header.Start + header.TotalLength;
            if (delimiterOffset >= source.Length)
            {
                token = default;
                return false;
            }

            var delimiter = ReadLineInfo(delimiterOffset);
            if (!IsTableDelimiter(delimiter.Trimmed))
            {
                token = default;
                return false;
            }

            var startLine = line;
            var rows = new List<MarkdownToken>();
            rows.Add(new MarkdownToken(
                MarkdownTokenKind.Table,
                new TextSpan(baseOffset + header.Start, header.TotalLength),
                baseLine + startLine,
                header.Column,
                0));
            rows.Add(new MarkdownToken(
                MarkdownTokenKind.Table,
                new TextSpan(baseOffset + delimiter.Start, delimiter.TotalLength),
                baseLine + startLine + 1,
                delimiter.Column,
                0));

            var currentOffset = delimiter.Start + delimiter.TotalLength;
            var currentLineNumber = startLine + 2;

            while (currentOffset < source.Length)
            {
                var candidate = ReadLineInfo(currentOffset);
                if (!candidate.Content.Contains('|') || candidate.IsBlank)
                {
                    break;
                }

                rows.Add(new MarkdownToken(
                    MarkdownTokenKind.Table,
                    new TextSpan(baseOffset + candidate.Start, candidate.TotalLength),
                    baseLine + currentLineNumber,
                    candidate.Column,
                    0));

                currentOffset = candidate.Start + candidate.TotalLength;
                currentLineNumber++;
            }

            AdvanceTo(currentOffset);
            pendingTokens = rows;
            pendingIndex = 1;
            token = rows[0];
            return true;
        }

        private void Advance(int count)
        {
            position += count;
            line++;
        }

        private void AdvanceTo(int absolutePosition)
        {
            var span = source[position..absolutePosition];
            line += CountLines(span);
            position = absolutePosition;
        }

        private LineInfo ReadLineInfo(int start)
        {
            var remaining = source[start..];
            var length = 0;
            var newlineLength = 0;

            for (var i = 0; i < remaining.Length; i++)
            {
                var ch = remaining[i];
                if (ch == '\r')
                {
                    length = i;
                    newlineLength = i + 1 < remaining.Length && remaining[i + 1] == '\n' ? 2 : 1;
                    goto Exit;
                }

                if (ch == '\n')
                {
                    length = i;
                    newlineLength = 1;
                    goto Exit;
                }
            }

            length = remaining.Length;

Exit:
            var content = remaining[..length];
            var column = CountLeadingWhitespace(content);
            var trimmed = column < content.Length ? content[column..] : ReadOnlySpan<char>.Empty;
            var isBlank = trimmed.IsEmpty;
            return new LineInfo(start, length, newlineLength, column, content, trimmed, isBlank);
        }

        private static bool IsFenceDelimiter(ReadOnlySpan<char> span, out char marker, out int markerLength)
        {
            marker = '\0';
            markerLength = 0;

            if (span.Length < 3)
            {
                return false;
            }

            var ch = span[0];
            if (ch is not '`' and not '~')
            {
                return false;
            }

            marker = ch;
            var index = 0;
            while (index < span.Length && span[index] == marker)
            {
                index++;
            }

            if (index < 3)
            {
                marker = '\0';
                markerLength = 0;
                return false;
            }

            markerLength = index;
            return true;
        }

        private static bool IsTableDelimiter(ReadOnlySpan<char> span)
        {
            var trimmed = span.Trim();
            if (trimmed.IsEmpty)
            {
                return false;
            }

            foreach (var ch in trimmed)
            {
                if (ch is not '|' and not ':' and not '-' and not ' ')
                {
                    return false;
                }
            }

            return trimmed.IndexOf('-') >= 0;
        }

        private static int CountLeadingWhitespace(ReadOnlySpan<char> span)
        {
            var count = 0;
            while (count < span.Length && (span[count] == ' ' || span[count] == '\t'))
            {
                count++;
            }

            return count;
        }

        private static int CountLines(ReadOnlySpan<char> span)
        {
            var count = 0;
            for (var i = 0; i < span.Length; i++)
            {
                if (span[i] == '\n')
                {
                    count++;
                }
            }

            if (span.Length > 0 && span[^1] != '\n')
            {
                count++;
            }

            return count;
        }

        internal static int EncodeFence(char marker, int length) => (marker << FenceMarkerShift) | length;

        internal static void DecodeFence(int value, out char marker, out int length)
        {
            marker = (char)(value >> FenceMarkerShift);
            length = value & 0xFFFF;
        }

        internal static int EncodeOrderedListValue(int number, MarkdownTaskState taskState) =>
            (taskState switch
            {
                MarkdownTaskState.Complete => 2,
                MarkdownTaskState.Incomplete => 1,
                _ => 0,
            } << 24) | Math.Clamp(number, 0, 0x00FFFFFF);

        private readonly ref struct LineInfo
        {
            public LineInfo(int start, int length, int newlineLength, int column, ReadOnlySpan<char> content, ReadOnlySpan<char> trimmed, bool isBlank)
            {
                Start = start;
                Length = length;
                NewlineLength = newlineLength;
                Column = column;
                Content = content;
                Trimmed = trimmed;
                IsBlank = isBlank;
            }

            public int Start { get; }

            public int Length { get; }

            public int NewlineLength { get; }

            public int TotalLength => Length + NewlineLength;

            public int Column { get; }

            public ReadOnlySpan<char> Content { get; }

            public ReadOnlySpan<char> Trimmed { get; }

            public bool IsBlank { get; }
        }
    }
}
