// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Parsing
{
    using System;
    using System.Buffers;
    using System.Collections.Generic;
    using SkiaMarkdown.Syntax;
    using SkiaMarkdown.Syntax.Green;
    using SkiaMarkdown.Syntax.Red;

    /// <summary>
    /// Parses Markdown source text into Roslyn-style green syntax nodes for block constructs.
    /// </summary>
    internal static class MarkdownSyntaxParser
    {
        public static GreenNode ParseDocument(ReadOnlyMemory<char> source, MarkdownSyntaxOptions options)
        {
            var tokens = Tokenize(source.Span, options.EnableGitHubExtensions);
            var blocks = BuildBlocks(source, tokens, options);

            var list = MarkdownSyntaxFactory.CreateList(blocks);
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.MarkdownDocument, list);
        }

        private static MarkdownToken[] Tokenize(ReadOnlySpan<char> source, bool enableGitHubExtensions)
        {
            var tokenizer = new MarkdownTokenizer(source, enableGitHubExtensions);
            var builder = ArrayPool<MarkdownToken>.Shared.Rent(Math.Max(32, source.Length / 32));
            var count = 0;

            try
            {
                while (tokenizer.TryRead(out var token))
                {
                    if (count >= builder.Length)
                    {
                        var newArray = ArrayPool<MarkdownToken>.Shared.Rent(builder.Length * 2);
                        Array.Copy(builder, newArray, builder.Length);
                        ArrayPool<MarkdownToken>.Shared.Return(builder);
                        builder = newArray;
                    }

                    builder[count++] = token;
                }

                var result = new MarkdownToken[count];
                Array.Copy(builder, result, count);
                return result;
            }
            finally
            {
                ArrayPool<MarkdownToken>.Shared.Return(builder);
            }
        }

        private static GreenNode?[] BuildBlocks(ReadOnlyMemory<char> source, IReadOnlyList<MarkdownToken> tokens, MarkdownSyntaxOptions options)
        {
            var blocks = new List<GreenNode?>(tokens.Count);
            var index = 0;

            while (index < tokens.Count)
            {
                var token = tokens[index];
                switch (token.Kind)
                {
                    case MarkdownTokenKind.BlankLine:
                        index++;
                        break;
                    case MarkdownTokenKind.Heading:
                        blocks.Add(ParseHeading(source.Span, token, options));
                        index++;
                        break;
                    case MarkdownTokenKind.Text:
                        blocks.Add(ParseParagraph(source, tokens, ref index, options));
                        break;
                    case MarkdownTokenKind.ThematicBreak:
                        blocks.Add(ParseThematicBreak(source.Span, token));
                        index++;
                        break;
                    case MarkdownTokenKind.FencedCodeBlock:
                        blocks.Add(ParseFencedCodeBlock(source.Span, token));
                        index++;
                        break;
                    case MarkdownTokenKind.OrderedListItem:
                    case MarkdownTokenKind.UnorderedListItem:
                        blocks.Add(ParseList(source.Span, tokens, ref index, options));
                        break;
                    case MarkdownTokenKind.BlockQuote:
                        blocks.Add(ParseBlockQuote(source.Span, tokens, ref index, options));
                        break;
                    case MarkdownTokenKind.Table:
                        blocks.Add(ParseTable(source.Span, tokens, ref index, options));
                        break;
                    case MarkdownTokenKind.FootnoteDefinition:
                        blocks.Add(options.EnableFootnotes
                            ? ParseFootnoteDefinition(source.Span, token, options)
                            : ParseFootnoteAsParagraph(source.Span, token, options));
                        index++;
                        break;
                    case MarkdownTokenKind.HtmlBlock:
                        blocks.Add(ParseHtmlBlock(source.Span, token));
                        index++;
                        break;
                    case MarkdownTokenKind.CustomContainer:
                        blocks.Add(ParseCustomContainer(source.Span, token));
                        index++;
                        break;
                    case MarkdownTokenKind.EndOfFile:
                        index = tokens.Count;
                        break;
                    default:
                        blocks.Add(ParseParagraph(source, tokens, ref index, options));
                        break;
                }
            }

            return blocks.ToArray();
        }

        private static GreenNode ParseHeading(ReadOnlySpan<char> source, MarkdownToken token, MarkdownSyntaxOptions options)
        {
            var line = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var level = token.Value;
            if (level <= 0)
            {
                level = CountLeadingCharacters(line, '#');
            }

            var contentStart = 0;
            while (contentStart < line.Length && line[contentStart] == '#')
            {
                contentStart++;
            }

            if (contentStart < line.Length && line[contentStart] == ' ')
            {
                contentStart++;
            }

            var content = line[contentStart..];
            var prefix = new string('#', Math.Clamp(level, 1, 6));

            var punctuationNode = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.HeadingPunctuation,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.HashToken, prefix));

            var inlineList = InlineMarkdownParser.Parse(content, options);
            var textNode = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.HeadingText, inlineList);

            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.AtxHeadingBlock, punctuationNode, textNode);
        }

        private static GreenNode ParseParagraph(ReadOnlyMemory<char> source, IReadOnlyList<MarkdownToken> tokens, ref int index, MarkdownSyntaxOptions options)
        {
            var span = source.Span;
            var start = tokens[index].Span.Start;
            var end = start;
            var current = index;

            while (current < tokens.Count)
            {
                var token = tokens[current];
                if (token.Kind != MarkdownTokenKind.Text)
                {
                    if (token.Kind == MarkdownTokenKind.BlankLine)
                    {
                        current++;
                    }

                    break;
                }

                end = token.Span.Start + token.Span.Length;
                current++;
            }

            index = current;
            var paragraphSpan = TextSpan.FromBounds(start, end);
            var paragraphSlice = span[paragraphSpan.Start..(paragraphSpan.Start + paragraphSpan.Length)];
            var inlineList = InlineMarkdownParser.Parse(paragraphSlice, options);
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ParagraphBlock, inlineList);
        }

        private static GreenNode ParseThematicBreak(ReadOnlySpan<char> source, MarkdownToken token)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var tokenNode = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, slice.ToString());
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ThematicBreakBlock, tokenNode);
        }

        private static GreenNode ParseFencedCodeBlock(ReadOnlySpan<char> source, MarkdownToken token)
        {
            MarkdownTokenizer.DecodeFence(token.Value, out var marker, out _);
            var slice = source[token.Span.Start..(token.Span.Start + token.Span.Length)];
            var firstLineLength = GetLineLength(slice);
            var opening = slice[..firstLineLength];
            var closingOffset = FindClosingFence(slice, marker);
            var closing = TrimTrailingNewline(slice[closingOffset..]);
            var middle = slice[firstLineLength..closingOffset];
            if (middle.Length > 0 && (middle[0] == '\r' || middle[0] == '\n'))
            {
                middle = middle[1..];
            }

            var openingNode = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.FencedCodeFence,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, TrimTrailingNewline(opening).ToString()));

            var textNode = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.FencedCodeText,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, TrimTrailingNewline(middle).ToString()));

            var closingText = TrimTrailingNewline(closing).ToString();
            var closingNode = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.FencedCodeFence,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, closingText));

            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.FencedCodeBlock, openingNode, textNode, closingNode);
        }

        private static GreenNode ParseList(ReadOnlySpan<char> source, IReadOnlyList<MarkdownToken> tokens, ref int index, MarkdownSyntaxOptions options)
        {
            var startToken = tokens[index];
            var isOrdered = startToken.Kind == MarkdownTokenKind.OrderedListItem;
            var items = new List<GreenNode?>();

            while (index < tokens.Count)
            {
                var token = tokens[index];
                if (token.Kind != startToken.Kind)
                {
                    if (token.Kind == MarkdownTokenKind.BlankLine &&
                        index + 1 < tokens.Count &&
                        tokens[index + 1].Kind == startToken.Kind)
                    {
                        index++;
                        continue;
                    }

                    break;
                }

                items.Add(ParseListItem(source, token, isOrdered, options));
                index++;
            }

            var listKind = isOrdered
                ? MarkdownSyntaxKind.OrderedListBlock
                : MarkdownSyntaxKind.BulletListBlock;

            var listNode = MarkdownSyntaxFactory.CreateList(items);
            return MarkdownSyntaxFactory.Node(listKind, listNode);
        }

        private static GreenNode ParseListItem(ReadOnlySpan<char> source, MarkdownToken token, bool isOrdered, MarkdownSyntaxOptions options)
        {
            var (contentSpan, taskState) = ExtractListItemContent(source, token, isOrdered);
            var contentSlice = TrimTrailingNewline(source[contentSpan.Start..(contentSpan.Start + contentSpan.Length)]);
            var inlineList = InlineMarkdownParser.Parse(contentSlice, options);

            var paragraph = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.ParagraphBlock,
                inlineList);

            if (taskState != MarkdownTaskState.None)
            {
                var taskToken = MarkdownSyntaxFactory.Token(
                    MarkdownSyntaxKind.TextToken,
                    taskState == MarkdownTaskState.Complete ? "[x]" : "[ ]");
                var taskNode = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.TaskListState, taskToken);
                return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ListItemBlock, taskNode, paragraph);
            }

            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ListItemBlock, paragraph);
        }

        private static GreenNode ParseBlockQuote(ReadOnlySpan<char> source, IReadOnlyList<MarkdownToken> tokens, ref int index, MarkdownSyntaxOptions options)
        {
            var paragraphs = new List<GreenNode?>();
            var depth = 0;

            while (index < tokens.Count && tokens[index].Kind == MarkdownTokenKind.BlockQuote)
            {
                var token = tokens[index];
                depth = Math.Max(depth, token.Value);
                var span = ExtractBlockQuoteContentSpan(source, token);
                if (span.Length > 0)
                {
                    var content = TrimTrailingNewline(source[span.Start..(span.Start + span.Length)]);
                    var inlineList = InlineMarkdownParser.Parse(content, options);
                    var paragraph = MarkdownSyntaxFactory.Node(
                        MarkdownSyntaxKind.ParagraphBlock,
                        inlineList);
                    paragraphs.Add(paragraph);
                }

                index++;
            }

            var quotePrefix = MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.BlockQuotePrefix,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, new string('>', Math.Max(depth, 1))));

            var contentList = MarkdownSyntaxFactory.CreateList(paragraphs);
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.BlockQuoteBlock, quotePrefix, contentList);
        }

        private static GreenNode ParseTable(ReadOnlySpan<char> source, IReadOnlyList<MarkdownToken> tokens, ref int index, MarkdownSyntaxOptions options)
        {
            var rows = new List<MarkdownToken>();
            while (index < tokens.Count && tokens[index].Kind == MarkdownTokenKind.Table)
            {
                rows.Add(tokens[index]);
                index++;
            }

            if (rows.Count < 2)
            {
                var fallback = rows[0];
                var slice = TrimTrailingNewline(source[fallback.Span.Start..(fallback.Span.Start + fallback.Span.Length)]);
                var inlineList = InlineMarkdownParser.Parse(slice, options);
                return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ParagraphBlock, inlineList);
            }

            var headerRow = CreateTableRowNode(source, rows[0], MarkdownSyntaxKind.TableHeader, options);
            var delimiterRow = CreateTableDelimiterRowNode(source, rows[1], options);

            var bodyRows = new List<GreenNode?>();
            for (var i = 2; i < rows.Count; i++)
            {
                bodyRows.Add(CreateTableRowNode(source, rows[i], MarkdownSyntaxKind.TableRow, options));
            }

            var bodyNode = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.TableBody, MarkdownSyntaxFactory.CreateList(bodyRows));

            return MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.TableBlock,
                headerRow,
                delimiterRow,
                bodyNode);
        }

        private static GreenNode ParseFootnoteDefinition(ReadOnlySpan<char> source, MarkdownToken token, MarkdownSyntaxOptions options)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var separator = slice.IndexOf("]:", StringComparison.Ordinal);
            if (separator <= 1)
            {
                return MarkdownSyntaxFactory.Node(
                    MarkdownSyntaxKind.FootnoteDefinitionBlock,
                    MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, slice.ToString()));
            }

            var nameSlice = slice[0..separator];
            var contentSlice = slice[(separator + 2)..].TrimStart();

            var nameToken = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, nameSlice.ToString());
            var nameNode = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.FootnoteName, nameToken);
            var inlineList = InlineMarkdownParser.Parse(contentSlice, options);
            var paragraph = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ParagraphBlock, inlineList);

            return MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.FootnoteDefinitionBlock,
                nameNode,
                paragraph);
        }

        private static GreenNode ParseFootnoteAsParagraph(ReadOnlySpan<char> source, MarkdownToken token, MarkdownSyntaxOptions options)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var inlineList = InlineMarkdownParser.Parse(slice, options);
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ParagraphBlock, inlineList);
        }

        private static GreenNode CreateTableRowNode(ReadOnlySpan<char> source, MarkdownToken token, MarkdownSyntaxKind kind, MarkdownSyntaxOptions options)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var segments = EnumerateTableSegments(slice);
            var cells = new List<GreenNode?>(segments.Count);

            foreach (var segment in segments)
            {
                var cellSlice = segment.Length > 0 ? slice.Slice(segment.StartOffset, segment.Length) : ReadOnlySpan<char>.Empty;
                var cellText = cellSlice.Trim();
                var inlineList = InlineMarkdownParser.Parse(cellText, options);
                cells.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.TableCell, inlineList));
            }

            var list = MarkdownSyntaxFactory.CreateList(cells);
            return MarkdownSyntaxFactory.Node(kind, list);
        }

        private static GreenNode CreateTableDelimiterRowNode(ReadOnlySpan<char> source, MarkdownToken token, MarkdownSyntaxOptions options)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var segments = EnumerateTableSegments(slice);
            var cells = new List<GreenNode?>(segments.Count);

            foreach (var segment in segments)
            {
                var cellSlice = segment.Length > 0 ? slice.Slice(segment.StartOffset, segment.Length) : ReadOnlySpan<char>.Empty;
                var trimmed = cellSlice.Trim();
                var alignment = DetermineTableAlignment(trimmed, options.EnableTableAlignment);
                var alignmentToken = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TableAlignmentToken, alignment);
                var rawToken = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, trimmed.ToString());
                cells.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.TableDelimiterCell, alignmentToken, rawToken));
            }

            var list = MarkdownSyntaxFactory.CreateList(cells);
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.TableDelimiterRow, list);
        }

        private static GreenNode ParseHtmlBlock(ReadOnlySpan<char> source, MarkdownToken token)
        {
            var slice = source[token.Span.Start..(token.Span.Start + token.Span.Length)];
            var text = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, slice.ToString());
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.HtmlBlock, text);
        }

        private static GreenNode ParseCustomContainer(ReadOnlySpan<char> source, MarkdownToken token)
        {
            var slice = source[token.Span.Start..(token.Span.Start + token.Span.Length)];
            var text = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, slice.ToString());
            return MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.CustomContainerBlock, text);
        }

        private static ReadOnlySpan<char> TrimTrailingNewline(ReadOnlySpan<char> span)
        {
            var end = span.Length;
            while (end > 0 && (span[end - 1] == '\n' || span[end - 1] == '\r'))
            {
                end--;
            }

            return span[..end];
        }

        private static int GetLineLength(ReadOnlySpan<char> span)
        {
            for (var i = 0; i < span.Length; i++)
            {
                if (span[i] == '\r' || span[i] == '\n')
                {
                    return i;
                }
            }

            return span.Length;
        }

        private static int FindClosingFence(ReadOnlySpan<char> span, char marker)
        {
            for (var i = span.Length - 1; i >= 0; i--)
            {
                if (span[i] == marker)
                {
                    var count = 1;
                    var j = i - 1;
                    while (j >= 0 && span[j] == marker)
                    {
                        count++;
                        j--;
                    }

                    if (count >= 3)
                    {
                        return j + 1;
                    }
                }
            }

            return span.Length;
        }

        private static int CountLeadingCharacters(ReadOnlySpan<char> span, char match)
        {
            var count = 0;
            while (count < span.Length && span[count] == match)
            {
                count++;
            }

            return count;
        }

        private static (TextSpan Span, MarkdownTaskState State) ExtractListItemContent(ReadOnlySpan<char> source, MarkdownToken token, bool isOrdered)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var index = 0;

            if (isOrdered)
            {
                while (index < slice.Length && char.IsDigit(slice[index]))
                {
                    index++;
                }

                if (index < slice.Length && (slice[index] == '.' || slice[index] == ')'))
                {
                    index++;
                }
            }
            else
            {
                if (index < slice.Length && (slice[index] == '-' || slice[index] == '*' || slice[index] == '+'))
                {
                    index++;
                }
            }

            if (index < slice.Length && slice[index] == ' ')
            {
                index++;
            }

            var taskState = MarkdownTaskState.None;
            if (index + 2 < slice.Length && slice[index] == '[' && slice[index + 2] == ']')
            {
                var marker = char.ToLowerInvariant(slice[index + 1]);
                taskState = marker == 'x' ? MarkdownTaskState.Complete : MarkdownTaskState.Incomplete;
                index += 3;
                if (index < slice.Length && slice[index] == ' ')
                {
                    index++;
                }
            }

            var trimmed = slice[index..].TrimStart();
            var offset = slice[index..].Length - trimmed.Length;
            var start = token.Span.Start + index + offset;
            return (new TextSpan(start, trimmed.Length), taskState);
        }

        private static TextSpan ExtractBlockQuoteContentSpan(ReadOnlySpan<char> source, MarkdownToken token)
        {
            var slice = TrimTrailingNewline(source[token.Span.Start..(token.Span.Start + token.Span.Length)]);
            var index = 0;

            while (index < slice.Length && slice[index] == '>')
            {
                index++;
                if (index < slice.Length && slice[index] == ' ')
                {
                    index++;
                }
            }

            var trimmed = slice[index..].TrimStart();
            var offset = slice[index..].Length - trimmed.Length;
            var start = token.Span.Start + index + offset;
            return new TextSpan(start, trimmed.Length);
        }

    private static IReadOnlyList<(int StartOffset, int Length)> EnumerateTableSegments(ReadOnlySpan<char> row)
    {
        var segments = new List<(int StartOffset, int Length)>();
        var start = 0;
        var index = 0;

            if (row.Length > 0 && row[0] == '|')
            {
                start = 1;
            }

            for (index = start; index <= row.Length; index++)
            {
                if (index == row.Length || row[index] == '|')
                {
                    var length = Math.Max(0, index - start);
                    segments.Add((start, length));
                    start = index + 1;
                }
            }

        return segments;
    }

    private static string DetermineTableAlignment(ReadOnlySpan<char> cell, bool enableAlignment)
    {
        if (!enableAlignment)
        {
            return "none";
        }

        if (cell.IsEmpty)
        {
            return "none";
        }

        var startsWithColon = cell.Length > 0 && cell[0] == ':';
        var endsWithColon = cell.Length > 0 && cell[^1] == ':';
        var hasDash = cell.IndexOf('-') >= 0;

        if (!hasDash)
        {
            return "none";
        }

        if (startsWithColon && endsWithColon)
        {
            return "center";
        }

        if (startsWithColon)
        {
            return "left";
        }

        if (endsWithColon)
        {
            return "right";
        }

        return "none";
    }

    }
}
