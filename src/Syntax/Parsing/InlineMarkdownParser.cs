// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Parsing
{
    using System;
    using System.Collections.Generic;
    using System.Text;
    using SkiaMarkdown.Syntax;
    using SkiaMarkdown.Syntax.Green;
    using SkiaMarkdown.Syntax.Utilities;

    /// <summary>
    /// Parses inline Markdown constructs into Roslyn green nodes.
    /// </summary>
    internal static class InlineMarkdownParser
    {
        public static GreenNode Parse(ReadOnlySpan<char> text, MarkdownSyntaxOptions options)
        {
            var nodes = new List<GreenNode?>();
            ParseInternal(text, nodes, options);
            return MarkdownSyntaxFactory.CreateList(nodes);
        }

        private static void ParseInternal(ReadOnlySpan<char> text, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            var index = 0;
            while (index < text.Length)
            {
                if (TryParseLineBreak(text, ref index, nodes))
                {
                    continue;
                }

                if (TryParseCodeSpan(text, ref index, nodes))
                {
                    continue;
                }

                if (TryParseInlineMath(text, ref index, nodes, options))
                {
                    continue;
                }

                if (TryParseStrongOrEmphasis(text, ref index, nodes, options))
                {
                    continue;
                }

                if (options.EnableStrikethrough && TryParseTildeDelimited(text, ref index, nodes, options))
                {
                    continue;
                }

                if (options.EnableHighlight && TryParseHighlight(text, ref index, nodes, options))
                {
                    continue;
                }

                if (TryParseImage(text, ref index, nodes, options))
                {
                    continue;
                }

                if (TryParseLink(text, ref index, nodes, options))
                {
                    continue;
                }

                if (options.EnableFootnotes && TryParseFootnoteReference(text, ref index, nodes))
                {
                    continue;
                }

                if (TryParseAutolinkOrHtml(text, ref index, nodes))
                {
                    continue;
                }

                if (TryParseEmoji(text, ref index, nodes, options))
                {
                    continue;
                }

                if (TryParseMention(text, ref index, nodes, options))
                {
                    continue;
                }

                if (TryParseEntity(text, ref index, nodes))
                {
                    continue;
                }

                if (TryParseTextRun(text, ref index, nodes, options))
                {
                    continue;
                }

                // Fallback to consume the current character as text to avoid infinite loops.
                nodes.Add(CreateTextNode(text.Slice(index, 1)));
                index++;
            }
        }

        private static bool TryParseTextRun(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            StringBuilder? builder = null;
            var originalIndex = index;

            while (index < text.Length)
            {
                Span<char> specials = stackalloc char[16];
                var count = 0;
                specials[count++] = '\r';
                specials[count++] = '\n';
                specials[count++] = '*';
                specials[count++] = '_';
                specials[count++] = '`';
                specials[count++] = '[';
                specials[count++] = '!';
                specials[count++] = '<';
                specials[count++] = '&';
                specials[count++] = '~';
                specials[count++] = '=';
                specials[count++] = '\\';
                if (options.EnableInlineMath)
                {
                    specials[count++] = '$';
                }

                if (options.EnableEmojiShortcodes)
                {
                    specials[count++] = ':';
                }

                if (options.EnableMentions)
                {
                    specials[count++] = '@';
                }

                var span = text[index..];
                var relative = SimdCharSearch.IndexOfAny(span, specials[..count]);

                if (relative == -1)
                {
                    if (builder is null)
                    {
                        nodes.Add(CreateTextNode(span));
                    }
                    else
                    {
                        builder.Append(span);
                        nodes.Add(CreateTextNode(builder.ToString()));
                    }

                    index = text.Length;
                    return true;
                }

                if (relative > 0)
                {
                    builder ??= new StringBuilder();
                    builder.Append(span[..relative]);
                    index += relative;
                }

                if (index >= text.Length)
                {
                    break;
                }

                var specialChar = text[index];
                if (specialChar == '\\' && index + 1 < text.Length)
                {
                    builder ??= new StringBuilder();
                    builder.Append(text[index + 1]);
                    index += 2;
                    continue;
                }

                break;
            }

            if (builder is not null && builder.Length > 0)
            {
                nodes.Add(CreateTextNode(builder.ToString()));
                return true;
            }

            if (index > originalIndex)
            {
                nodes.Add(CreateTextNode(text[originalIndex..index]));
                return true;
            }

            return false;
        }

        private static bool TryParseCodeSpan(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes)
        {
            if (text[index] != '`')
            {
                return false;
            }

            var tickCount = CountRepeated(text, index, '`');
            var closing = FindClosingTicks(text, index + tickCount, tickCount);
            if (closing == -1)
            {
                return false;
            }

            var content = text[(index + tickCount)..closing];
            var codeText = content.ToString().Trim();
            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, codeText);
            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.CodeSpanInline, token));
            index = closing + tickCount;
            return true;
        }

        private static bool TryParseInlineMath(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (!options.EnableInlineMath || text[index] != '$')
            {
                return false;
            }

            if (IsEscaped(text, index))
            {
                return false;
            }

            var closing = index + 1;
            while (closing < text.Length)
            {
                if (text[closing] == '$' && !IsEscaped(text, closing))
                {
                    break;
                }

                closing++;
            }

            if (closing >= text.Length || text[closing] != '$' || closing == index + 1)
            {
                return false;
            }

            var content = text[(index + 1)..closing];
            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, content.ToString());
            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.MathInline, token));
            index = closing + 1;
            return true;
        }

        private static bool TryParseStrongOrEmphasis(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            var marker = text[index];
            if (marker is not ('*' or '_'))
            {
                return false;
            }

            var runLength = CountRepeated(text, index, marker);

            if (runLength >= 2 && TryParseDelimitedInline(text, ref index, nodes, marker, 2, MarkdownSyntaxKind.StrongEmphasisInline, options))
            {
                return true;
            }

            return TryParseDelimitedInline(text, ref index, nodes, marker, 1, MarkdownSyntaxKind.EmphasisInline, options);
        }

        private static bool TryParseTildeDelimited(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (!options.EnableStrikethrough)
            {
                return false;
            }

            if (text[index] != '~' || index + 1 >= text.Length || text[index + 1] != '~')
            {
                return false;
            }

            return TryParseDelimitedInline(text, ref index, nodes, '~', 2, MarkdownSyntaxKind.StrikethroughInline, options);
        }

        private static bool TryParseHighlight(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (!options.EnableHighlight)
            {
                return false;
            }

            if (text[index] != '=' || index + 1 >= text.Length || text[index + 1] != '=')
            {
                return false;
            }

            return TryParseDelimitedInline(text, ref index, nodes, '=', 2, MarkdownSyntaxKind.HighlightInline, options);
        }

        private static bool TryParseDelimitedInline(
            ReadOnlySpan<char> text,
            ref int index,
            List<GreenNode?> nodes,
            char marker,
            int markerLength,
            MarkdownSyntaxKind kind,
            MarkdownSyntaxOptions options)
        {
            var runLength = CountRepeated(text, index, marker);
            if (runLength < markerLength)
            {
                return false;
            }

            var searchStart = index + markerLength;
            var closing = FindClosingDelimiter(text, searchStart, marker, markerLength);
            if (closing == -1)
            {
                return false;
            }

            var inner = text.Slice(searchStart, closing - searchStart);
            var innerNodes = new List<GreenNode?>();
            ParseInternal(inner, innerNodes, options);
            var listNode = MarkdownSyntaxFactory.CreateList(innerNodes);

            nodes.Add(MarkdownSyntaxFactory.Node(kind, listNode));
            index = closing + markerLength;
            return true;
        }

        private static bool TryParseImage(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (text[index] != '!' || index + 1 >= text.Length || text[index + 1] != '[')
            {
                return false;
            }

            var position = index + 1;
            if (!TryParseLinkCore(text, ref position, options, out var labelList, out var destinationToken))
            {
                return false;
            }

            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.ImageInline, labelList, destinationToken));
            index = position;
            return true;
        }

        private static bool TryParseLink(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (text[index] != '[')
            {
                return false;
            }

            var position = index;
            if (!TryParseLinkCore(text, ref position, options, out var labelList, out var destinationToken))
            {
                return false;
            }

            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.LinkInline, labelList, destinationToken));
            index = position;
            return true;
        }

        private static bool TryParseLinkCore(
            ReadOnlySpan<char> text,
            ref int index,
            MarkdownSyntaxOptions options,
            out GreenNode labelList,
            out GreenNode destinationToken)
        {
            labelList = MarkdownSyntaxFactory.CreateList(Array.Empty<GreenNode?>());
            destinationToken = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, string.Empty);

            if (text[index] != '[')
            {
                return false;
            }

            var labelStart = index + 1;
            var closingLabel = FindClosingBracket(text, labelStart);
            if (closingLabel == -1 || closingLabel + 1 >= text.Length || text[closingLabel + 1] != '(')
            {
                return false;
            }

            var labelSpan = text.Slice(labelStart, closingLabel - labelStart);
            var labelNodes = new List<GreenNode?>();
            ParseInternal(labelSpan, labelNodes, options);
            labelList = MarkdownSyntaxFactory.CreateList(labelNodes);

            var destinationStart = closingLabel + 2;
            var closingParen = FindClosingParen(text, destinationStart);
            if (closingParen == -1)
            {
                return false;
            }

            var destinationSpan = text.Slice(destinationStart, closingParen - destinationStart).Trim();
            destinationToken = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, destinationSpan.ToString());
            index = closingParen + 1;
            return true;
        }

        private static bool TryParseAutolinkOrHtml(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes)
        {
            if (text[index] != '<')
            {
                return false;
            }

            var closing = text[(index + 1)..].IndexOf('>');
            if (closing == -1)
            {
                return false;
            }

            var inner = text[(index + 1)..(index + 1 + closing)];
            var tokenText = text.Slice(index, closing + 2).ToString();

            if (IsAutolink(inner))
            {
                nodes.Add(MarkdownSyntaxFactory.Node(
                    MarkdownSyntaxKind.AutolinkInline,
                    MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, tokenText)));
            }
            else
            {
                nodes.Add(MarkdownSyntaxFactory.Node(
                    MarkdownSyntaxKind.HtmlInline,
                    MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, tokenText)));
            }

            index += closing + 2;
            return true;
        }

        private static bool TryParseEmoji(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (!options.EnableEmojiShortcodes || text[index] != ':' || index + 1 >= text.Length)
            {
                return false;
            }

            var closing = text[(index + 1)..].IndexOf(':');
            if (closing == -1)
            {
                return false;
            }

            var candidate = text[(index + 1)..(index + 1 + closing)];
            if (candidate.Length == 0)
            {
                return false;
            }

            for (var i = 0; i < candidate.Length; i++)
            {
                if (!IsEmojiShortcodeChar(candidate[i]))
                {
                    return false;
                }
            }

            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, text.Slice(index, closing + 2).ToString());
            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.EmojiInline, token));
            index += closing + 2;
            return true;
        }

        private static bool TryParseMention(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes, MarkdownSyntaxOptions options)
        {
            if (!options.EnableMentions || text[index] != '@')
            {
                return false;
            }

            if (index > 0 && IsMentionBodyChar(text[index - 1]))
            {
                return false;
            }

            var current = index + 1;
            while (current < text.Length && IsMentionBodyChar(text[current]))
            {
                current++;
            }

            if (current == index + 1)
            {
                return false;
            }

            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, text.Slice(index, current - index).ToString());
            nodes.Add(MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.MentionInline, token));
            index = current;
            return true;
        }

        private static bool TryParseFootnoteReference(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes)
        {
            if (text[index] != '[' || index + 2 >= text.Length || text[index + 1] != '^')
            {
                return false;
            }

            var closing = text[(index + 2)..].IndexOf(']');
            if (closing == -1)
            {
                return false;
            }

            var label = text[(index + 2)..(index + 2 + closing)];
            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, label.ToString());
            var node = MarkdownSyntaxFactory.Node(MarkdownSyntaxKind.FootnoteReferenceInline, token);
            nodes.Add(node);
            index += closing + 3;
            return true;
        }

        private static bool TryParseEntity(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes)
        {
            if (text[index] != '&')
            {
                return false;
            }

            var semicolon = text[(index + 1)..].IndexOf(';');
            if (semicolon == -1)
            {
                return false;
            }

            var entity = text.Slice(index, semicolon + 2);
            nodes.Add(MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.EntityInline,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, entity.ToString())));

            index += semicolon + 2;
            return true;
        }

        private static bool TryParseLineBreak(ReadOnlySpan<char> text, ref int index, List<GreenNode?> nodes)
        {
            var ch = text[index];
            if (ch is not ('\r' or '\n'))
            {
                return false;
            }

            var newlineLength = ch == '\r' && index + 1 < text.Length && text[index + 1] == '\n' ? 2 : 1;
            var hardBreak = index >= 2 && text[index - 1] == ' ' && text[index - 2] == ' ';
            var kind = hardBreak ? MarkdownSyntaxKind.HardBreakInline : MarkdownSyntaxKind.SoftBreakInline;
            var token = MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, hardBreak ? "  \n" : "\n");
            nodes.Add(MarkdownSyntaxFactory.Node(kind, token));
            index += newlineLength;
            return true;
        }

        private static GreenNode CreateTextNode(ReadOnlySpan<char> span) =>
            MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.TextInline,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, span.ToString()));

        private static GreenNode CreateTextNode(string text) =>
            MarkdownSyntaxFactory.Node(
                MarkdownSyntaxKind.TextInline,
                MarkdownSyntaxFactory.Token(MarkdownSyntaxKind.TextToken, text));

        private static int CountRepeated(ReadOnlySpan<char> text, int index, char value)
        {
            var count = 0;
            while (index + count < text.Length && text[index + count] == value)
            {
                count++;
            }

            return count;
        }

        private static int FindClosingTicks(ReadOnlySpan<char> text, int index, int tickCount)
        {
            for (var position = index; position <= text.Length - tickCount; position++)
            {
                var match = true;
                for (var j = 0; j < tickCount; j++)
                {
                    if (text[position + j] != '`')
                    {
                        match = false;
                        break;
                    }
                }

                if (match)
                {
                    return position;
                }
            }

            return -1;
        }

        private static int FindClosingDelimiter(ReadOnlySpan<char> text, int index, char marker, int length)
        {
            for (var position = index; position <= text.Length - length; position++)
            {
                var match = true;
                for (var j = 0; j < length; j++)
                {
                    if (text[position + j] != marker)
                    {
                        match = false;
                        break;
                    }
                }

                if (match)
                {
                    return position;
                }
            }

            return -1;
        }

        private static int FindClosingBracket(ReadOnlySpan<char> text, int index)
        {
            var depth = 0;
            for (var position = index; position < text.Length; position++)
            {
                var ch = text[position];
                if (ch == '\\')
                {
                    position++;
                    continue;
                }

                if (ch == '[')
                {
                    depth++;
                }
                else if (ch == ']')
                {
                    if (depth == 0)
                    {
                        return position;
                    }

                    depth--;
                }
            }

            return -1;
        }

        private static int FindClosingParen(ReadOnlySpan<char> text, int index)
        {
            var depth = 0;
            for (var position = index; position < text.Length; position++)
            {
                var ch = text[position];
                if (ch == '(')
                {
                    depth++;
                }
                else if (ch == ')')
                {
                    if (depth == 0)
                    {
                        return position;
                    }

                    depth--;
                }
            }

            return -1;
        }

        private static bool IsAutolink(ReadOnlySpan<char> span) =>
            span.Contains("://", StringComparison.OrdinalIgnoreCase) ||
            span.Contains('@');

        private static bool IsEmojiShortcodeChar(char ch) =>
            char.IsLetterOrDigit(ch) || ch is '_' or '+' or '-';

        private static bool IsMentionBodyChar(char ch) =>
            char.IsLetterOrDigit(ch) || ch is '_' or '-';

        private static bool IsEscaped(ReadOnlySpan<char> text, int index) =>
            index > 0 && text[index - 1] == '\\';
    }
}
