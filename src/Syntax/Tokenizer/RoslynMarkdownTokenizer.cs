// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Tokenizer
{
    using System;
    using System.Collections.Immutable;
    using SkiaMarkdown.Syntax.Green;
    using SkiaMarkdown.Syntax.Utf16;

    /// <summary>
    /// Tokenizes Markdown source text into Roslyn-style green tokens while preserving trivia.
    /// </summary>
    internal static class RoslynMarkdownTokenizer
    {
        public static ImmutableArray<GreenToken> Tokenize(ReadOnlySpan<char> text)
        {
            var reader = new Utf16CharReader(text);
            var tokenBuilder = new MarkdownTokenBuilder();
            var tokens = ImmutableArray.CreateBuilder<GreenToken>();

            while (true)
            {
                tokenBuilder.Reset();
                CollectLeadingTrivia(ref reader, tokenBuilder);

                if (reader.IsEnd)
                {
                    tokens.Add(tokenBuilder.CreateToken(MarkdownSyntaxKind.EndOfFileToken, string.Empty));
                    break;
                }

                var tokenText = ParseTokenText(text, ref reader, out var tokenKind);

                CollectTrailingTrivia(ref reader, tokenBuilder);

                tokens.Add(tokenBuilder.CreateToken(tokenKind, tokenText));
            }

            return tokens.ToImmutable();
        }

        private static string ParseTokenText(ReadOnlySpan<char> text, ref Utf16CharReader reader, out MarkdownSyntaxKind tokenKind)
        {
            var start = reader.Position;
            var ch = reader.Current;

            if (Utf16CharacterClassifier.IsPunctuation(ch))
            {
                if (ch is '`' or '~')
                {
                    var count = CountSame(ref reader, ch);
                    var slice = text.Slice(start, count);
                    tokenKind = ch == '`'
                        ? MarkdownSyntaxKind.BacktickToken
                        : MarkdownSyntaxKind.TildeToken;
                    return slice.ToString();
                }

                reader.Advance();
                tokenKind = MarkdownSyntaxFacts.GetTokenKind(ch);
                return text[start..reader.Position].ToString();
            }

            if (Utf16CharReader.IsLineBreak(ch))
            {
                var width = Utf16CharReader.MeasureLineBreak(reader.Remaining);
                tokenKind = MarkdownSyntaxKind.TextToken;
                var slice = text.Slice(start, width);
                reader.Advance(width);
                return slice.ToString();
            }

            var span = reader.ConsumeWhile(static c =>
                !Utf16CharacterClassifier.IsWhitespace(c) &&
                !Utf16CharReader.IsLineBreak(c) &&
                !Utf16CharacterClassifier.IsPunctuation(c));

            tokenKind = span.Length == 1 && char.IsDigit(span[0])
                ? MarkdownSyntaxKind.DigitsToken
                : MarkdownSyntaxKind.TextToken;

            if (tokenKind == MarkdownSyntaxKind.TextToken && span.Length == 1 && char.IsLetter(span[0]))
            {
                tokenKind = MarkdownSyntaxKind.IdentifierToken;
            }

            return span.ToString();
        }

        private static void CollectLeadingTrivia(ref Utf16CharReader reader, MarkdownTokenBuilder tokenBuilder)
        {
            while (!reader.IsEnd)
            {
                var ch = reader.Current;

                if (Utf16CharacterClassifier.IsWhitespace(ch))
                {
                    if (ch == ' ')
                    {
                        var count = CountSame(ref reader, ' ');
                        tokenBuilder.AddLeadingTrivia(MarkdownTriviaTable.GetWhitespaceTrivia(count));
                        continue;
                    }

                    if (ch == '\t')
                    {
                        reader.Advance();
                        tokenBuilder.AddLeadingTrivia(MarkdownTriviaTable.GetTabTrivia());
                        continue;
                    }
                }

                if (Utf16CharReader.IsLineBreak(ch))
                {
                    var width = Utf16CharReader.MeasureLineBreak(reader.Remaining);
                    var trivia = width == 2
                        ? MarkdownTriviaTable.GetCarriageReturnLineFeedTrivia()
                        : MarkdownTriviaTable.GetLineFeedTrivia();
                    reader.Advance(width);
                    tokenBuilder.AddLeadingTrivia(trivia);
                    continue;
                }

                break;
            }
        }

        private static void CollectTrailingTrivia(ref Utf16CharReader reader, MarkdownTokenBuilder tokenBuilder)
        {
            while (!reader.IsEnd)
            {
                var ch = reader.Current;

                if (Utf16CharacterClassifier.IsWhitespace(ch))
                {
                    if (ch == ' ')
                    {
                        var count = CountSame(ref reader, ' ');
                        tokenBuilder.AddTrailingTrivia(MarkdownTriviaTable.GetWhitespaceTrivia(count));
                        continue;
                    }

                    if (ch == '\t')
                    {
                        reader.Advance();
                        tokenBuilder.AddTrailingTrivia(MarkdownTriviaTable.GetTabTrivia());
                        continue;
                    }
                }

                if (Utf16CharReader.IsLineBreak(ch))
                {
                    var width = Utf16CharReader.MeasureLineBreak(reader.Remaining);
                    var trivia = width == 2
                        ? MarkdownTriviaTable.GetCarriageReturnLineFeedTrivia()
                        : MarkdownTriviaTable.GetLineFeedTrivia();
                    reader.Advance(width);
                    tokenBuilder.AddTrailingTrivia(trivia);
                    continue;
                }

                break;
            }
        }

        private static int CountSame(ref Utf16CharReader reader, char match)
        {
            var count = 0;
            while (!reader.IsEnd && reader.Current == match)
            {
                reader.Advance();
                count++;
            }

            return count;
        }
    }
}
