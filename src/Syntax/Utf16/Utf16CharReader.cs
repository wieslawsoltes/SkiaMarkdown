// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Utf16
{
    using System;

    /// <summary>
    /// Provides low-level, allocation-free traversal over UTF-16 encoded Markdown text.
    /// </summary>
    internal ref struct Utf16CharReader
    {
        private readonly ReadOnlySpan<char> text;
        private int position;

        public Utf16CharReader(ReadOnlySpan<char> text)
        {
            this.text = text;
            position = 0;
        }

        public bool IsEnd => position >= text.Length;

        public int Position => position;

        public ReadOnlySpan<char> Remaining => text[position..];

        public char Current => text[position];

        public bool TryPeek(out char ch)
        {
            if (IsEnd)
            {
                ch = default;
                return false;
            }

            ch = text[position];
            return true;
        }

        public char Peek(int lookahead)
        {
            var index = position + lookahead;
            if (index >= text.Length)
            {
                return '\0';
            }

            return text[index];
        }

        public void Advance(int count = 1)
        {
            position = Math.Clamp(position + count, 0, text.Length);
        }

        public ReadOnlySpan<char> Slice(int start, int length) => text.Slice(start, length);

        public ReadOnlySpan<char> SliceFrom(int start) => text[start..text.Length];

        public ReadOnlySpan<char> ConsumeWhile(Func<char, bool> predicate)
        {
            var start = position;
            while (!IsEnd && predicate(text[position]))
            {
                position++;
            }

            return text[start..position];
        }

        public bool TryConsume(ReadOnlySpan<char> value)
        {
            if (!Remaining.StartsWith(value, StringComparison.Ordinal))
            {
                return false;
            }

            position += value.Length;
            return true;
        }

        public static bool IsLineBreak(char ch) => ch is '\r' or '\n';

        public static int MeasureLineBreak(ReadOnlySpan<char> span)
        {
            if (span.IsEmpty)
            {
                return 0;
            }

            if (span[0] == '\r')
            {
                return span.Length > 1 && span[1] == '\n' ? 2 : 1;
            }

            return span[0] == '\n' ? 1 : 0;
        }
    }
}
