// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Semantics
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using SkiaMarkdown.Syntax.Red;

    /// <summary>
    /// Builds table semantics from Roslyn-style syntax trees.
    /// </summary>
    internal static class TableSemanticModel
    {
        public static MarkdownTableSemantic Build(
            MarkdownSyntaxNode tableNode,
            MarkdownSyntaxOptions options,
            out IReadOnlyList<MarkdownDiagnostic> diagnostics)
        {
            if (tableNode.Kind != MarkdownSyntaxKind.TableBlock)
            {
                throw new ArgumentException("Node must be a TableBlock.", nameof(tableNode));
            }

            var diagnosticList = new List<MarkdownDiagnostic>();

            var headerNode = tableNode.ChildNodes().FirstOrDefault(n => n.Kind == MarkdownSyntaxKind.TableHeader)
                ?? throw new InvalidOperationException("Table header missing.");
            var delimiterNode = tableNode.ChildNodes().FirstOrDefault(n => n.Kind == MarkdownSyntaxKind.TableDelimiterRow)
                ?? throw new InvalidOperationException("Table delimiter row missing.");
            var bodyNode = tableNode.ChildNodes().FirstOrDefault(n => n.Kind == MarkdownSyntaxKind.TableBody);

            var alignments = ExtractAlignments(delimiterNode);
            var headerRow = BuildRow(headerNode, options, diagnosticList);
            var bodyRows = bodyNode is null
                ? Array.Empty<MarkdownTableRowSemantic>()
                : bodyNode.ChildNodes()
                    .Where(n => n.Kind == MarkdownSyntaxKind.TableRow)
                    .Select(n => BuildRow(n, options, diagnosticList))
                    .ToArray();

            diagnostics = diagnosticList;
            return new MarkdownTableSemantic(alignments, headerRow, bodyRows, diagnostics);
        }

        private static MarkdownTableRowSemantic BuildRow(
            MarkdownSyntaxNode rowNode,
            MarkdownSyntaxOptions options,
            List<MarkdownDiagnostic> diagnostics)
        {
            var cells = new List<MarkdownTableCellSemantic>();
            foreach (var cellNode in EnumerateChildren(rowNode, MarkdownSyntaxKind.TableCell))
            {
                var cellSemantics = InlineSemanticModelBuilder.Build(cellNode, options, out var cellDiagnostics);
                diagnostics.AddRange(cellDiagnostics);
                cells.Add(new MarkdownTableCellSemantic(cellSemantics, cellDiagnostics));
            }

            return new MarkdownTableRowSemantic(cells);
        }

        private static IReadOnlyList<MarkdownTableColumnAlignment> ExtractAlignments(MarkdownSyntaxNode delimiterNode)
        {
            var alignments = new List<MarkdownTableColumnAlignment>();
            foreach (var cell in EnumerateChildren(delimiterNode, MarkdownSyntaxKind.TableDelimiterCell))
            {
                var token = cell.ChildNodesAndTokens()
                    .FirstOrDefault(e => e.IsToken && e.AsToken().Kind == MarkdownSyntaxKind.TableAlignmentToken);
                var alignment = MarkdownTableColumnAlignment.None;
                if (token.IsToken)
                {
                    alignment = token.AsToken().Text switch
                    {
                        "left" => MarkdownTableColumnAlignment.Left,
                        "right" => MarkdownTableColumnAlignment.Right,
                        "center" => MarkdownTableColumnAlignment.Center,
                        _ => MarkdownTableColumnAlignment.None
                    };
                }

                alignments.Add(alignment);
            }

            return alignments;
        }

        private static IEnumerable<MarkdownSyntaxNode> EnumerateChildren(MarkdownSyntaxNode node, MarkdownSyntaxKind kind)
        {
            foreach (var child in node.ChildNodes())
            {
                if (child.Kind == kind)
                {
                    yield return child;
                }
                else if (child.Kind == MarkdownSyntaxKind.SyntaxList)
                {
                    foreach (var nested in EnumerateChildren(child, kind))
                    {
                        yield return nested;
                    }
                }
            }
        }
    }
}
