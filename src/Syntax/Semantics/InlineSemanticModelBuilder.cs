// <auto-generated/>
#nullable enable
namespace SkiaMarkdown.Syntax.Semantics
{
    using System;
    using System.Collections.Generic;
    using SkiaMarkdown.Syntax;
    using SkiaMarkdown.Syntax.Red;

    /// <summary>
    /// Builds inline semantics from the Roslyn-style red tree.
    /// </summary>
    internal static class InlineSemanticModelBuilder
    {
        public static IReadOnlyList<MarkdownInlineSemantic> Build(
            MarkdownSyntaxNode node,
            MarkdownSyntaxOptions options,
            out IReadOnlyList<MarkdownDiagnostic> diagnostics)
        {
            if (node is null)
            {
                throw new ArgumentNullException(nameof(node));
            }

            var diagnosticList = new List<MarkdownDiagnostic>();
            var result = BuildNode(node, options, diagnosticList);
            diagnostics = diagnosticList;
            return result;
        }

        private static IReadOnlyList<MarkdownInlineSemantic> BuildNode(
            MarkdownSyntaxNode node,
            MarkdownSyntaxOptions options,
            List<MarkdownDiagnostic> diagnostics)
        {
            return node.Kind switch
            {
                MarkdownSyntaxKind.SyntaxList => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.ParagraphBlock => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.HeadingText => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.TableCell => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.ListItemBlock => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.BlockQuoteBlock => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.TableRow => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.TableHeader => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.TableBody => BuildChildren(node, options, diagnostics),
                MarkdownSyntaxKind.TextInline => CreateSingle(new TextInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.CodeSpanInline => CreateSingle(new CodeSpanInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.EmphasisInline => CreateSingle(new EmphasisInlineSemantic(BuildChildren(node, options, diagnostics))),
                MarkdownSyntaxKind.StrongEmphasisInline => CreateSingle(new StrongInlineSemantic(BuildChildren(node, options, diagnostics))),
                MarkdownSyntaxKind.StrikethroughInline => CreateSingle(new StrikethroughInlineSemantic(BuildChildren(node, options, diagnostics))),
                MarkdownSyntaxKind.HighlightInline => CreateSingle(new HighlightInlineSemantic(BuildChildren(node, options, diagnostics))),
                MarkdownSyntaxKind.MathInline => CreateSingle(new MathInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.LinkInline => CreateSingle(BuildLink(node, options, diagnostics)),
                MarkdownSyntaxKind.ImageInline => CreateSingle(BuildImage(node, options, diagnostics)),
                MarkdownSyntaxKind.AutolinkInline => CreateSingle(new AutolinkInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.HtmlInline => CreateSingle(BuildHtml(node, diagnostics)),
                MarkdownSyntaxKind.EntityInline => CreateSingle(BuildEntity(node, diagnostics)),
                MarkdownSyntaxKind.HardBreakInline => CreateSingle(new BreakInlineSemantic(true)),
                MarkdownSyntaxKind.SoftBreakInline => CreateSingle(new BreakInlineSemantic(false)),
                MarkdownSyntaxKind.EmojiInline => CreateSingle(new EmojiInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.MentionInline => CreateSingle(new MentionInlineSemantic(CollectText(node))),
                MarkdownSyntaxKind.TaskListState => options.EnableTaskLists
                    ? CreateSingle(new TaskListMarkerInlineSemantic(IsTaskStateChecked(node)))
                    : Array.Empty<MarkdownInlineSemantic>(),
                MarkdownSyntaxKind.FootnoteReferenceInline => CreateSingle(new FootnoteReferenceInlineSemantic(CollectText(node))),
                _ => BuildChildren(node, options, diagnostics),
            };
        }

        private static IReadOnlyList<MarkdownInlineSemantic> BuildChildren(
            MarkdownSyntaxNode node,
            MarkdownSyntaxOptions options,
            List<MarkdownDiagnostic> diagnostics)
        {
            var list = new List<MarkdownInlineSemantic>();
            foreach (var child in node.ChildNodes())
            {
                var childResult = BuildNode(child, options, diagnostics);
                if (childResult.Count > 0)
                {
                    list.AddRange(childResult);
                }
            }

            return list;
        }

        private static IReadOnlyList<MarkdownInlineSemantic> CreateSingle(MarkdownInlineSemantic value) =>
            value is null
                ? Array.Empty<MarkdownInlineSemantic>()
                : new[] { value };

        private static string CollectText(MarkdownSyntaxNode node)
        {
            var texts = new List<string>();
            foreach (var element in node.ChildNodesAndTokens())
            {
                if (element.IsToken)
                {
                    texts.Add(element.AsToken().Text);
                }
                else
                {
                    texts.Add(CollectText(element.AsNode()));
                }
            }

            return string.Concat(texts);
        }

        private static LinkInlineSemantic BuildLink(MarkdownSyntaxNode node, MarkdownSyntaxOptions options, List<MarkdownDiagnostic> diagnostics)
        {
            MarkdownSyntaxNode? labelNode = null;
            string destination = string.Empty;

            foreach (var element in node.ChildNodesAndTokens())
            {
                if (element.IsNode)
                {
                    labelNode = element.AsNode();
                }
                else
                {
                    destination = element.AsToken().Text;
                }
            }

            if (!Uri.TryCreate(destination, UriKind.RelativeOrAbsolute, out _))
            {
                diagnostics.Add(new MarkdownDiagnostic(
                    "MD001",
                    $"Link destination '{destination}' is not a valid URI.",
                    node.Span));
            }

            var children = labelNode is null ? Array.Empty<MarkdownInlineSemantic>() : BuildNode(labelNode, options, diagnostics);
            return new LinkInlineSemantic(children, destination);
        }

        private static ImageInlineSemantic BuildImage(MarkdownSyntaxNode node, MarkdownSyntaxOptions options, List<MarkdownDiagnostic> diagnostics)
        {
            MarkdownSyntaxNode? altNode = null;
            string source = string.Empty;

            foreach (var element in node.ChildNodesAndTokens())
            {
                if (element.IsNode)
                {
                    altNode = element.AsNode();
                }
                else
                {
                    source = element.AsToken().Text;
                }
            }

            if (!Uri.TryCreate(source, UriKind.RelativeOrAbsolute, out _))
            {
                diagnostics.Add(new MarkdownDiagnostic(
                    "MD002",
                    $"Image source '{source}' is not a valid URI.",
                    node.Span));
            }

            var alt = altNode is null ? Array.Empty<MarkdownInlineSemantic>() : BuildNode(altNode, options, diagnostics);
            return new ImageInlineSemantic(alt, source);
        }

        private static HtmlInlineSemantic BuildHtml(MarkdownSyntaxNode node, List<MarkdownDiagnostic> diagnostics)
        {
            diagnostics.Add(new MarkdownDiagnostic(
                "MD003",
                "Raw HTML detected. Ensure appropriate sanitization before rendering.",
                node.Span,
                MarkdownDiagnosticSeverity.Warning));

            return new HtmlInlineSemantic(CollectText(node));
        }

        private static EntityInlineSemantic BuildEntity(MarkdownSyntaxNode node, List<MarkdownDiagnostic> diagnostics)
        {
            var value = CollectText(node);
            if (!value.EndsWith(";", StringComparison.Ordinal))
            {
                diagnostics.Add(new MarkdownDiagnostic(
                    "MD004",
                    $"HTML entity '{value}' is missing a terminating ';'.",
                    node.Span,
                    MarkdownDiagnosticSeverity.Warning));
            }

            return new EntityInlineSemantic(value);
        }

        private static bool IsTaskStateChecked(MarkdownSyntaxNode node)
        {
            var text = CollectText(node);
            return text.IndexOf('x', StringComparison.OrdinalIgnoreCase) >= 0;
        }
    }
}
